# -*- coding: binary -*-

module Msf::Exploit::Git

###
#
# This module implements the pkt-line format used
# by Git.
#
###
module PktLine

  FLUSH_PKT         = "0000"
  DELIM_PKT         = "0001"
  RESPONSE_END_PKT  = "0002"

  ###
  #
  # pkt-line format
  # pkt-line     =  data-pkt / flush-pkt
  # data-pkt     =  pkt-len pkt-payload
  # pkt-len      =  4*(HEXDIG)
  # pkt-payload  =  (pkt-len - 4)*(OCTET)
  # source: https://git-scm.com/docs/protocol-common
  #
  ###
  def self.generate_pkt_line(data, type: 'data-pkt')
    case type
    when 'data-pkt'
      generate_data_pkt(data)
    when 'flush-pkt'
      FLUSH_PKT 
    end
  end

  def self.generate_data_pkt(data)
    return nil unless data

    return nil if data.empty?

    # The length should include the length
    # of pkt-payload plus four characters for
    # pkt-len plus another for the terminating LF
    pkt_line_len = data.length + 4 + 1
    pkt_line_len = pkt_line_len.to_s(16).rjust(4, '0')

    "#{pkt_line_len}#{data}\n"
  end

  ###
  #
  # compute_request   =  want_list
  #        have_list
  #        request_end
  # request_end       =  "0000" / "done"
  # source: https://git-scm.com/docs/http-protocol/2.16.6
  #
  ###
  def self.read_want_have_list(pkt_lines = [])
    return [] if pkt_lines.empty?
    wants = Array.new

    # Discard request_end line if there is one
    request_ends = [ "#{FLUSH_PKT}0009done", "#{FLUSH_PKT}0009#{FLUSH_PKT}" ]
    if request_ends.include?(pkt_lines[-1])
      pkt_lines.pop
    end

    pkt_lines.each { |line| wants << get_pkt_line_data(line) }
    wants
  end

  ###
  #
  # Reads a single pkt_line and returns the data
  #
  ###
  def self.get_pkt_line_data(pkt_line)
    line_len = pkt_line[0, 4].to_i(16) 
    pkt_line[4, line_len]
  end
end
end
